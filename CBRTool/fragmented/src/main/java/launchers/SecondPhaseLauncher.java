package launchers;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.List;

import org.apache.log4j.Logger;

import codegeneration.AtLeastOneConditionFactory;
import filter.ConditionFilter;
import pathconditions.MetadataMethod;
import utils.StaticAnalysisUtilities;

import static defs.Defs.*;

/**
 * Reduce path conditions from results in log files
 *
 */
public class SecondPhaseLauncher {
	
	final static Logger logger = Logger.getLogger(SecondPhaseLauncher.class);

	private List<MetadataMethod> results = new ArrayList<MetadataMethod>();
	private ArrayList<String> expressions = new ArrayList<String>();
	
	public SecondPhaseLauncher() {
		logger.debug("Starting SecondPhaseLauncher...");
		filterResultsFromTestSuiteExecution();
		retrieveSymbolicExecutionResults();
		retrieveFilteredConditions();
		filterSymbolicExecutionResults();
		compilateConditions();
	}

	public static void main(String[] args) {
		new SecondPhaseLauncher();
	}

	
	private void filterResultsFromTestSuiteExecution() {
		logger.debug("Filtering results from test suite execution...");
		ConditionFilter conditionFilter = new ConditionFilter(false);
		String[][] results = conditionFilter.getResults();
		String[] expressions = conditionFilter.getExpressions();
		conditionFilter.printResults("f_results.log", results);
		conditionFilter.printExpressions("f_expressions.log", expressions);
		
		results = conditionFilter.heuristicPruning();

		conditionFilter.printResults("h_results.log", results);
		conditionFilter.printExpressions("h_expressions.log", conditionFilter.getExpressions());
	}

	private void filterSymbolicExecutionResults() {
		logger.debug("Filtering symbolic executions results...");
		List<MetadataMethod> tempResults = new ArrayList<MetadataMethod>();
		
		for (MetadataMethod mdm: results) {
			
			if (!StaticAnalysisUtilities.containsMethodName(expressions, mdm.getName()))
				continue;
			
			mdm.filterPathConditionsByExpressions(expressions);
			tempResults.add(mdm);
		}
		results = tempResults;
	}

	private void retrieveFilteredConditions() {
		logger.debug("Retrieving filtered conditions...");
		File file = new File("../logs/h_expressions.log");

		try (BufferedReader br = new BufferedReader(new FileReader(file))) {
			String line;
			while ((line = br.readLine()) != null) {
				expressions.add(line);
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void retrieveSymbolicExecutionResults() {
		logger.debug("Retrieving symbolic execution results...");
		File folder = new File(serializedObjects);
		File[] listOfFiles = folder.listFiles();

		for (int i = 0; i < listOfFiles.length; i++) {
			if (listOfFiles[i].isFile()) {
				FileInputStream fis;
				ObjectInputStream in;
				MetadataMethod mdm;
				try {
					fis = new FileInputStream(listOfFiles[i]);
					in = new ObjectInputStream(fis);
					mdm = (MetadataMethod) in.readObject();
					results.add(mdm);
					in.close();
				} catch (IOException | ClassNotFoundException e) {
					logger.error(e.getMessage());
				}
			}
		}
	}

	public void compilateConditions() {
		logger.debug("Compile filtered conditions...");
		StaticAnalysisUtilities.delete(new File(autogeneratedEvaluators));
		
		AtLeastOneConditionFactory atLeastCondition = new AtLeastOneConditionFactory(results);
		atLeastCondition.writeJavaClass();
	}
}
